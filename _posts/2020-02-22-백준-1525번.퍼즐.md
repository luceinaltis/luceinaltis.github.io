---
layout: post
title:  "백준 - 1525번, 퍼즐"
description: 알고리즘 문제풀이
date: 2020-02-22
categories: C++ PS Algorithm BFS
---

### 사용되는 알고리즘

- BFS

  

### 시간복잡도

- O(nlgn)

  

### 풀이

​    이런 유형의 문제를 연습해두면 유용할 거 같다. 이와 비슷한 문제는 9019번, 1697번 문제가 있으니 좀 더 익히고 싶은 사람은 참고하자.

​    문제를 처음 봤을 때는, 먼저 시간 제한과 메모리 제한을 먼저 보는 편이다. 알고리즘 문제같은 경우, 특히 백준사이트 같은 경우는 문제에 힌트가 있는 경우가 많다. 이 문제의 시간 제한은 1초, 메모리는 32MB로 상당히 빡빡한 것을 알 수 있다. 이런 탐색유형의 문제를 먼저 그래프로 구현하기 위해 노력해봤다.

​    단순히 그래프로 만들기위해 방문했다는 표시를 위한 배열의 크기를 계산해보자면 `visited[1000000000] = 10억`으로 시간복잡도를 `O(n)`으로 봐도 1초안에는 일단 불가능하다는 것을 알 수 있다.  하지만 곰곰히 생각해보면 BFS를 하면서 나오는 시간 복잡도는 `O(V)`이다. V를 노드의 갯수로 보고 3\*3표를 하나의 노드로 바라보자.

​    그렇다면 나올 수 있는 V의 수는 몇가지 경우의 수일까? 경우의 수로 계산해보자면 하나의 순열이니 계산하면 `9! = 362,880 `으로 30만이라는 생각보다 작은 수가 나온다. 그렇다면  3\*3표를 하나의 노드로 바라봐도 큰 상관이 없을 것 같다. 하지만 문제는 방문 여부를 담을 만한 크기의 공간을 만들 수 없다는 점이다. 그렇다면 시간복잡도를 약간 포기하면서 문제를 풀어보자. V개의 노드를 각각 방문 할 때마다 인접 노드의 방문 여부를 다른 자료구조에 담아 계산해보자 이진트리의 구조를 이용하면 삽입, 삭제, 탐색이 모두 `log(V)`안에 이루어지니 인접 노드의 방문여부를 물을 때 마다 `log(V)`의 시간을 더 소비해도 총 시간복잡도는 `V*log(V)`로 1초 정도에는 가능하겠다는 생각이 든다.  다행히 STL에는 set이라는 자료구조를 제공해줘서 이를 이용했다.

​	그렇다면, 다음으로 떠오르는 문제는 어떻게 이것을 그래프로 구현할 것인가? 이다. 보통 그래프라 하면 노드와 노드 사이의 거리가 주어진다. 그리고, 해당 노드는 0~n까지의 숫자로 주어진다. 이 문제는 약간 다르다. 하지만 곰곰히 생각해보면 우리는 이미 그래프로 구현가능하다는 것을 알 수 있다. 노드와 노드 사이의 거리는 1로 자동으로 주어진 셈이다. 그리고 늘어나는 거리의 경우는 따로 저장하지 않아도 BFS의 특징을 이용하면 구할 수 있다. 출발점부터 해당 노드까지의 거리가 최소인 노드를 모두 queue에 담아 최소거리를 기준으로 queue를 진행시키면 된다.

​	queue에서 거리를 기준으로 pop과 push를 반복한다고 보면 된다. 그러다 해당 노드를 찾으면 빠져나와주는 최적화를 해주자.



### 소스 코드

<script src="https://gist.github.com/luceinaltis/42377bed7e8b5baf01519760b7a09fbd.js"></script>
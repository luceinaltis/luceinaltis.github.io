---
layout: post
title:  "백준 - 1517번, 버블소트"
description: 알고리즘 문제풀이
date:   2020-01-23 21:03:36 +0530
categories: C++ PS Algorithm
---
### 사용되는 알고리즘

- Divide and Conquer
- Merge Sort

### 시간복잡도

- O(nlgn)

### 풀이

​	문제에서는, 버블 소트를 할 경우 스왑되는 총 횟수를 구하라고 한다.  단순히 생각하면 버블 소트를 직접 구현하여 swap이 한 번 진행될 때마다, 카운트하는 방법을 생각 할 수 있다. 그러나 버블 소트의 시간복잡도는 O(n^2)으로,이는 `n <= 500,000`, `시간 제한 1초` 인 점을 고려했을 때 `n^2 <= 250,000,000,000`이 되니 버블 소트를 직접 구현하는 naive한 방법으로는 절대 풀 수 없다.

​	

​	하지만, Count inversion 방법을 이용하면 O(nlgn)안에 풀 수 있다. 분할정복을 이용해 문제를 풀면 된다. 먼저 Merge sort 과정 중 밑의 그림과 같이 [1, 3]와 [2, 4]로 divide된 배열 2개를 생각해보자.  두 개의 배열을 스왑하면서 정렬된 배열로 만들기 위해서는 (3, 2)의 스왑이 필요하다. 즉, 이 부분문제를 해결하기 위해서는 총 1번의 스왑이 필요한 것이다.  우리는 이 1번이란 횟수가 어떻게 나왔는지만 알면 된다.

<img src="\assets\images\2020-01-21-백준 - 1517번, 버블소트\1517_1.png" alt="1517_1" style="zoom:33%;" />

그림을 잘 살펴보면 1번의 횟수는 각 선분들의 교차점의 횟수와도 같다는 걸 알 수 있다. 그렇다면 우리는 이 교차점의 갯수만 알면 해당 부분 문제를 풀 수 있다. 

쉽게 말하기 위해 divide된 왼쪽 배열을 A, 오른쪽 배열을 B라 하겠다. 문제를 해결하기 위해서 각 배열들의 최소값들을 비교한다. 이 때 3가지 경우의 수가 있다.



> 1. (A배열의 최소값 < B배열의 최소값)인 경우

<img src="C:\Users\82109\Desktop\luceinaltis.github.io\assets\images\2020-01-21-백준 - 1517번, 버블소트\1517_2.png" alt="1517_2" style="zoom:33%;" />

이 경우에 스왑 횟수는 카운트하지 않고 A배열의 인덱스를 하나 증가시킨다.

> 2. (A배열의 최소값 > B배열의 최소값)인 경우

<img src="C:\Users\82109\Desktop\luceinaltis.github.io\assets\images\2020-01-21-백준 - 1517번, 버블소트\1517_3.png" alt="1517_3" style="zoom:33%;" />

이 경우에 스왑 횟수는 A배열의 value가 3인 곳부터 A배열 마지막 인덱스까지의 갯수다. 즉 value가 3인 인덱스가 1이니 (A배열의 사이즈 - (3의 인덱스)) = (2 - 1) = 1을 카운트한다.

> 3. (A배열의 최소값 = B배열의 최소값)인 경우

이 경우에 스왑 횟수는 카운트하지 않고 A배열의 인덱스를 하나 증가시킨다.



이때 1번 경우와 3번 경우에 카운트를 하지않고 인덱스만 증가시키는 이유는 이미 2번 경우에 스왑 되는 카운트가 1번과 3번 경우를 포함시키고 있기 때문이다. 이와 같이 부분 문제를 풀어 나오는 모든 카운트들을 더한다면 답을 얻을 수 있다. 

### 소스 코드

```c++
/* C++ */
#include <iostream>
#include <vector>

using namespace std;

typedef long long ll;

vector<int> A;
vector<int> sub_A;

ll conquer(int left, int mid, int right);

/* 분할된 배열들이 합쳐질 때, 필요한 스왑의 총 횟수 반환 */
ll divide(int left, int right)
{
	ll count_inv = 0;
	if (left < right)
	{
		int mid = (left + right) / 2;
		
		/* 배열을 분할한다 */
		count_inv += divide(left, mid);
		count_inv += divide(mid + 1, right);

		/* 분할된 배열들을 정복한다 */
		count_inv += conquer(left, mid + 1, right);
	}
	return count_inv;
}

/* 분할된 배열들이 합쳐질 때, 필요한 스왑의 횟수 반환 */
ll conquer(int left, int mid, int right)
{
	/* 왼쪽, 오른쪽 배열을 순환하는 인덱스 */
	int i = left, j = mid;
	/* sub_A 배열에 해당하는 인덱스 */
	int k = left;

	ll count_inv = 0;

	while (i <= mid - 1 && j <= right)
	{
		if (A[i] > A[j])
		{
			sub_A[k++] = A[j++];

			count_inv += mid - i;
		}
		else if(A[i] <= A[j])
		{
			sub_A[k++] = A[i++];
		}
	}

	while(i <= mid -1)
		sub_A[k++] = A[i++];

	while (j <= right)
		sub_A[k++] = A[j++];

	/* 정렬된 sub_A를 A에 삽입하는 과정 */
	for (int i = left; i <= right; ++i)
	{
		A[i] = sub_A[i];
	}

	return count_inv;
}

int main()
{
	ios::sync_with_stdio(0);
	cin.tie(0);

	int n;

	cin >> n;

	A.assign(n, 0);
	sub_A.assign(n, 0);

	for (int i = 0; i < n; ++i)
	{
		cin >> A[i];
	}

	cout << divide(0, n - 1) << '\n';

	return 0;
}
```

### 참조

- inversion count : [https://www.geeksforgeeks.org/counting-inversions/](https://www.geeksforgeeks.org/counting-inversions/)
- 스왑 횟수가 inversion count와 같은 이유 : [https://stackoverflow.com/questions/20990127/sorting-a-sequence-by-swapping-adjacent-elements-using-minimum-swaps](https://stackoverflow.com/questions/20990127/sorting-a-sequence-by-swapping-adjacent-elements-using-minimum-swaps)
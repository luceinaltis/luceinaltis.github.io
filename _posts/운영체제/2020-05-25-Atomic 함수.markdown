---
layout: page
title:  "Atomic 함수의 이용"
date:   2020-05-25
categories: [운영체제]
---
이 글은 개인적으로 공부한 부분을 정리해놓은 글 입니다.

부정확한 정보가 있을 수 있으니 이에 유의하여 글을 읽어주시기 바랍니다 :)

## Atomic 함수란?

---

atomic 함수를 알기 위해서는 먼저 atomic의 의미를 파악해야 된다.

atomic은 해석하면 원자성, 극소의라는 뜻이다.

컴퓨터 공학에서는 이를 `다른 프로세스에서의 간섭을 받지 않고 데이터가 옳게 계산된다`라고 정도로 해석된다.

이는 특히 데이터가 공유되는 멀티 스레딩 환경에서 문제가 된다.

멀티 스레딩 환경에서는 스레드는 스택의 메모리만 따로 관리하고 그 외 다른 메모리는 공유한다.

그러므로, 만약 같은 메모리 주소를 참조하고 읽고 쓰는 과정을 반복하는 스레드가 여러 개 있고 동시에 실행된다면 문제가 된다.

```cpp
# MIPS assembly
lw $1 ($2)
add $1 $1 1
sw $1 ($2)
```

위와 같은 어셈블리 코드를 보면서 이해해보자.

```cpp
lw $1 ($2)
```

첫째 줄에서  $2 레지스터가 가르키는 메모리 주소를 참조하여 $1 레지스터에 저장한다.

 ```cpp
add $1 $1 1
 ```

둘째 줄에서는 $1 레지스터 값을 1만큼 올려준다.

 ```cpp
sw $1 ($2)
 ```

마지막 줄에서는 $1 레지스터 값을 ($2)가 가르키는 메모리 주소에 저장한다.

이와 같은 코드를 여러번 실행시키는 스레드 2개를 가정하자.

참고로, 각 스레드의 레지스터는 동일한 레지스터가 아니다.

<img src="https://user-images.githubusercontent.com/60007241/82789309-06da8c80-9ea5-11ea-90a8-58af4efb7729.png" alt="table1" style="zoom:80%;" />

다음과 같은 실행 흐름은 atomic이 깨진 상황이다.

실제 엔지니어가 의도한 것은 각각의 스레드에서 1을 더하여 저장된 메모리의 결과 값이 +2가 되는 것이다.

하지만, 실제로 ($2)에 저장된 값을 보면 +1만 된 것을 볼 수 있다.

이는 메모리의 값을 레지스터로 읽어오는 과정과 실제 +1이 이뤄지는 그 중간사이에 또 다른 스레드의 명령어가 실행되서 발생하는 문제이다.

이를 데이터 레이싱 현상이라고도 부른다.

이런 문제를 방지하기위해 함수 실행을 하드웨어의 적절한 지원으로 하나의 명령어처럼 실행되는 함수를 atomic 함수라고 부른다.

## Atomic 방식과 mutex lock방식의 차이

---

atomic을 보장하기 위해서는 엔지니어가 사용할 수 있는 수많은 방법이 있지만 이 글에서는 atomic 함수와 mutex 방식만을 비교 하였다.

먼저, mutex lock을 사용하는 방법을 보자.

```cpp
pthread_mutex_lock(&lock);
/* - critical section - */
/* - any function - */
/* - critical section - */
pthread_mutex_unlock(&lock);
```

pthread에서는 이런 atomic을 보장하기 위한 방법으로 lock을 얻고 포기하는 방법을 제공한다.

mutex 방식의 lock을 이용하면 같은 lock을 잡기 위해 다양한 스레드가 lock 요청을 한다.

잡는데 성공한 스레드는 그대로 cirical section으로 진입하여 코드를 실행한다.

lock을 잡지 못한 스레드는 lock을 잡은 스레드가 lock을 놓을 때까지 대기한다.

critical section의 부분은 lock으로 인해 보호되어 그 중간에 다른 스레드가 실행되지 않는 것을 보장해준다.

이를 보장함으로서 critical section의 atomic또한 보장되는 것이다.

하지만, lock을 얻는데 실패한 스레드가 다른 스레드가 lock을 놓기를 마냥 기다리기 때문에 이에 허비되는 시간은 성능저하로 이어진다.

이와 같은 성능저하를 막기 위해 하드웨어적으로 atomic하게 실행되는 함수들을 제공한다.

```cpp
atomic_function() // 이 자체가 atomic하게 실행된다.
```

하드웨어적으로 atomic_function들이 하나의 instruction처럼 실행되기 때문에 lock을 얻기 위해 허비되는 시간이 없다.

또한, 코드 또한 간결해지는 장점이 있다.

이 같이 지원되는 atomic_function을 보려면 [링크](https://gcc.gnu.org/onlinedocs/gcc/_005f_005fatomic-Builtins.html)를 참조하자.



## 실제 코드 응용

---

다양한 atomic 함수가 있지만 코드에는 c++11에서 지원하는 atomic 클래스의 atomic_exchange를 이용하였다.

그리고, 리눅스에서는 실행하기위해 -lpthread 태그를 붙여야 한다.

```cpp
#include <iostream>
#include <atomic>
#include <ctime>
#define ITER 1000000
using namespace std;

typedef struct __node_t {
    int key;
    struct __node_t *next;
} node_t;

typedef struct __list_t {
    atomic<node_t*> head;
    pthread_mutex_t lock; // mutex
} list_t;

/* -------------------------------- mutex -------------------------- */
void List_Init_mutex(list_t *L)
{
    L->head = NULL;
    pthread_mutex_init(&L->lock, NULL);
}

int List_Insert_mutex(list_t *L, const int& key)
{
    node_t *new_node = new node_t;
    if(new_node == NULL)
    {
        perror("new");
        pthread_mutex_unlock(&L->lock);
        return -1;
    }
    new_node->key = key;

    /* mutex를 이용해 데이터를 보호한 부분 */
    pthread_mutex_lock(&L->lock);
    new_node->next = L->head;
    L->head = new_node;
    pthread_mutex_unlock(&L->lock);
    return 0;
}

void* pthread_main_mutex(void* l)
{
    for(int i = 0; i < ITER; i++)
    {
        List_Insert_mutex((list_t*)l, i+1);
        // cout << i << " insert complete" << '\n';
    }
    pthread_exit(0);
}
/* -------------------------------- mutex -------------------------- */
/* ------------------------------ test_and_set --------------------- */

void List_Init_tas(list_t *L)
{
    L->head = NULL;
}

int List_Insert_tas(list_t *L, const int& key)
{
    node_t *new_node = new node_t;
    if(new_node == NULL)
    {
        perror("new");
        return -1;
    }
    
    new_node->key = key;
    node_t* old_head = atomic_exchange(&L->head, new_node);
    new_node->next = old_head;
    return 0;
}

void* pthread_main_tas(void* l)
{
    for(int i = 0; i < ITER; i++)
    {
        List_Insert_tas((list_t*)l, i+1);
        // cout << i << " insert complete" << '\n';
    }
    pthread_exit(0);
}

/* ------------------------------ test_and_set --------------------- */


int main()
{
    clock_t start, end;
    int i, ret[10];
    pthread_t t[10];
    clock_t mutex, tas;
    list_t* l_mutex = new list_t;
    list_t* l_tas = new list_t;

    cout << "thread의 개수 : 10\n";
    cout << "thread 당 삽입하는 노드의 개수 : " << ITER << '\n';

/* -------------------------------- mutex -------------------------- */

    cout << "test mutex start\n"; 

    start = clock();
    List_Init_mutex(l_mutex);
    for(i = 0; i < 10; i++)
    {
        if(pthread_create(&t[i], NULL, pthread_main_mutex, (void*)l_mutex) != 0)
        {
            cout << t[i] << " create error\n";
            return -1;
        }
    }

    for(i = 0; i < 10; i++)
    {
        if(pthread_join(t[i], (void**)&ret[i]) != 0)
        {
            cout << t[i] << " join error\n";
            return -1;
        }
    }
    end = clock();

    mutex = (double)(end - start);
    cout << "test mutex end\n"; 
    
/* -------------------------------- mutex -------------------------- */
/* ------------------------------ test_and_set --------------------- */

    cout << "test tas start\n";

    start = clock();
    List_Init_tas(l_tas);

    for(i = 0; i < 10; i++)
    {
        if(pthread_create(&t[i], NULL, pthread_main_tas, (void*)l_tas) != 0)
        {
            cout << t[i] << " create error\n";
            return -1;
        }
    }

    for(i = 0; i < 10; i++)
    {
        if(pthread_join(t[i], (void**)&ret[i]) != 0)
        {
            cout << t[i] << " join error\n";
            return -1;
        }
    }
    end = clock();

    tas = (double)(end - start);

    cout << "test tas end\n";

/* ------------------------------ test_and_set --------------------- */

    cout << "mutex의 실행 시간 : " << (double)mutex/CLOCKS_PER_SEC << "s\n";
    cout << "tas의 실행 시간 : " << (double)tas/CLOCKS_PER_SEC << "s\n";

    return 0;
}
```

위의 코드는 링크드 리스트의 삽입을 예제로 구현해 놓은 것이다.

실제 실행 시간도 mutex방식과 atomic함수 방식에 차이가 있는 것을 확인 할 수 있다.

<img src="https://user-images.githubusercontent.com/60007241/82789303-05a95f80-9ea5-11ea-8f23-989d6d5633d9.png" alt="result1" style="zoom:100%;" />





